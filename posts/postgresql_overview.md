PostgreSQL은 세계에서 가장 진보적인 오픈 소스 관계형 데이터베이스로 평가습니다. 뛰어난 안정성, 강력한 기능 세트, 높은 확장성 덕분에 소규모 애플리케이션부터 대규모 엔터프라이즈 시스템에 이르기까지 폭넓게 사용되고 있습니다. 이 글에서는 PostgreSQL이 어떻게 데이터를 저장하고 트랜잭션을 처리하며, 높은 성능과 안정성을 동시에 달성하는지 그 내부 구조와 핵심 메커니즘을 심층적으로 분석해봅니다.

# 1. PostgreSQL의 핵심 특징

PostgreSQL의 강력함은 그 기반이 되는 두 가지 핵심 특징에서 비롯된다.

## 객체-관계형 데이터베이스 (Object-Relational Database)

PostgreSQL은 순수한 관계형 데이터베이스를 넘어 객체-관계형 데이터베이스(ORDBMS)를 표방한다. 이는 전통적인 관계형 데이터베이스의 기능(테이블, 행, 외래 키 등)에 객체 지향 프로그래밍의 개념(사용자 정의 데이터 타입, 함수, 상속 등)을 결합한 모델이다. 이러한 구조 덕분에 PostgreSQL은 정형화된 관계형 워크로드뿐만 아니라, 복잡하고 유연한 반정형 데이터 패턴(예: JSON, XML)까지 효과적으로 처리할 수 있는 유연성을 갖추게 된다.

## 완전한 ACID 트랜잭션 지원

데이터베이스의 신뢰성을 보장하는 가장 중요한 원칙은 ACID 모델이다. PostgreSQL은 ACID 모델을 엄격하게 구현하여 데이터의 무결성과 일관성을 보장한다.

- **원자성 (Atomicity)**: 트랜잭션은 '전부 아니면 전무(All-or-Nothing)' 원칙에 따라 동작한다. 트랜잭션 내의 모든 작업이 성공적으로 완료되어야 커밋(commit)되며, 하나라도 실패하면 모든 변경 사항이 롤백(rollback)되어 이전 상태로 돌아간다.
- **일관성 (Consistency)**: 트랜잭션은 데이터베이스를 항상 하나의 유효한 상태에서 다른 유효한 상태로만 전환시킨다. 데이터베이스에 정의된 모든 규칙과 제약 조건은 트랜잭션 전후로 항상 만족되어야 한다.
- **고립성 (Isolation)**: 여러 트랜잭션이 동시에 실행될 때 서로에게 영향을 미치지 않도록 격리한다. PostgreSQL은 MVCC(다중 버전 동시성 제어)를 통해 높은 수준의 고립성을 제공하면서도 동시성을 극대화한다.
- **지속성 (Durability)**: 일단 트랜잭션이 성공적으로 커밋되면, 그 결과는 영구적으로 저장된다. 시스템 장애(예: 정전, OS 충돌)가 발생하더라도 커밋된 데이터는 손실되지 않는다.

# 2. PostgreSQL 아키텍처

PostgreSQL은 다중 프로세스 기반의 클라이언트-서버 모델로 동작하며, 논리적 구조와 물리적 저장소를 분리하여 유연성과 안정성을 확보한다.

## 클라이언트-서버 모델

PostgreSQL 시스템의 중심에는 `postmaster`라는 마스터 프로세스가 있다. 이 프로세스는 데이터베이스 클러스터 전체를 관리하며, 클라이언트의 연결 요청을 수신하고 인증을 처리한다. 클라이언트(애플리케이션 또는 `psql`과 같은 CLI 도구)가 연결을 요청하면, `postmaster`는 해당 연결을 전담할 새로운 백엔드 프로세스(backend process)를 생성한다. 이후 모든 통신은 클라이언트와 이 백엔드 프로세스 간에 TCP를 통해 직접 이루어진다.

## 주요 프로세스 구성

- **백엔드 프로세스 (Backend Processes)**: 각 클라이언트 연결마다 하나씩 생성되며, 클라이언트가 보낸 SQL 쿼리를 파싱, 실행하고 결과를 반환하는 역할을 담당한다.
- **백그라운드 워커 (Background Workers)**: 데이터베이스 운영에 필요한 보조 작업을 수행한다. 캐싱, 주기적인 통계 정보 수집, 체크포인트(Checkpoint), 그리고 가장 중요한 VACUUM 프로세스가 여기에 포함된다.
- **Writer 및 WAL 프로세스**: 데이터의 영구 저장 및 복구를 관리하는 핵심 프로세스다. Writer는 메모리의 변경된 데이터를 디스크에 기록하고, WAL(Write-Ahead Logging) 프로세스는 모든 변경 사항을 로그 파일에 먼저 기록하여 데이터 지속성을 보장한다.

## 데이터 클러스터와 저장소 분리

PostgreSQL의 모든 데이터는 디스크 상의 특정 디렉터리, 즉 데이터 클러스터(Data Cluster)에 저장된다. 여기에는 데이터베이스, 스키마, 테이블, 인덱스, WAL 로그 등 모든 물리적 파일이 포함된다. 중요한 점은 PostgreSQL이 논리적 구조와 물리적 저장소를 분리했다는 것이다. 쿼리가 실행되는 방식(논리)과 데이터가 디스크에 저장되는 방식(물리)이 독립적으로 관리되므로, 내부 저장 구조를 변경하더라도 애플리케이션에 영향을 주지 않으며, 장애 허용성과 시스템 유연성이 크게 향상된다.

# 3. 데이터 저장 모델

PostgreSQL은 데이터를 어떻게 물리적으로 디스크에 저장할까? 그 핵심에는 힙 파일, 페이지, 튜플이라는 개념이 있다.

## 힙 파일 (Heap Files)과 페이지 (Pages)

각 테이블은 하나 이상의 힙 파일(Heap File)로 디스크에 저장된다. 이 힙 파일은 고정된 크기(기본값 8KB)를 갖는 페이지(Page)들의 집합으로 구성된다. 즉, 테이블 데이터는 여러 페이지에 나뉘어 저장되는 구조다.

페이지는 헤더와 실제 데이터 영역으로 나뉜다. 헤더에는 페이지의 메타데이터(여유 공간 정보, 트랜잭션 포인터 등)가 저장되고, 데이터 영역에는 여러 개의 행(row) 데이터가 저장된다. 페이지는 실제 행 데이터를 직접 담는 대신, 해당 행의 위치를 가리키는 아이템 포인터(Item Pointer) 배열을 유지하여 효율적인 데이터 접근을 가능하게 한다.

## 튜플 (Tuples): 행의 내부 표현

PostgreSQL에서 행은 내부적으로 튜플(Tuple)이라는 단위로 표현된다. 튜플은 사용자가 입력한 실제 데이터뿐만 아니라, MVCC(다중 버전 동시성 제어)를 구현하기 위한 중요한 메타데이터를 함께 저장한다.

> **튜플의 주요 메타데이터**  
> xmin: 이 튜플을 생성한 트랜잭션의 ID (Transaction ID).  
> xmax: 이 튜플을 삭제(또는 업데이트)한 트랜잭션의 ID. 초기에는 0으로 설정된다.  
> 기타 가시성(visibility) 정보: 트랜잭션의 커밋 여부 등을 나타내는 비트 플래그.

튜플은 페이지 내에서 고정된 순서 없이 추가되며, 새로운 데이터가 들어오면 페이지의 가용 공간에 순차적으로 기록된다.

# 4. TOAST: 대용량 데이터 처리 기법

PostgreSQL의 페이지 크기는 8KB로 고정되어 있고, 하나의 행(튜플)은 반드시 단일 페이지 안에 들어가야 한다는 제약이 있다. 하지만 TEXT, BYTEA, JSONB 타입처럼 8KB를 초과하는 대용량 데이터를 저장해야 할 경우 어떻게 처리할까? 이 문제를 해결하기 위한 자동화된 메커니즘이 바로 TOAST(The Oversized Attribute Storage Technique)이다.

## TOAST의 작동 전략

TOAST는 두 가지 주요 전략을 사용하여 대용량 데이터를 처리한다.

1. **압축 (Compression)**:필드 값이 일정 크기(기본 2KB)를 초과하면, PostgreSQL은 내부 압축 알고리즘(PGLZ 또는 LZ4)을 사용해 데이터를 압축한다. 압축 후 크기가 페이지에 들어갈 수 있다면, 압축된 상태로 메인 테이블에 그대로 저장된다.

2. **아웃-오브-라인 저장 (Out-of-line Storage)**:압축만으로도 페이지 크기 제약을 만족시키지 못하거나, 특정 데이터 타입이 아웃-오브-라인 저장을 우선하도록 설정된 경우, 해당 필드의 데이터는 별도로 자동 생성된 TOAST 테이블로 옮겨진다. 이 데이터는 여러 조각(chunk)으로 나뉘어 저장될 수 있다. 원본 테이블의 행에는 TOAST 테이블에 저장된 데이터의 위치를 가리키는 작은 포인터만 남게 된다. 이 모든 과정은 사용자에게 투명하게 자동으로 처리된다.

# 5. 트랜잭션과 동시성 제어: MVCC

다수의 사용자가 동시에 데이터베이스에 접근할 때 발생할 수 있는 충돌을 어떻게 제어할까? PostgreSQL은 전통적인 잠금(Locking) 방식의 단점을 보완하기 위해 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라는 정교한 메커니즘을 사용한다.

## MVCC의 목적과 작동 방식

MVCC의 핵심 목표는 읽기 작업이 쓰기 작업을 차단하지 않고, 쓰기 작업 또한 읽기 작업을 차단하지 않도록 하여 동시성을 극대화하는 것이다. 이를 위해 MVCC는 데이터를 수정할 때 기존 행을 덮어쓰는 대신, 새로운 버전의 행을 생성한다. 각 논리적 행은 여러 개의 물리적 버전(튜플)을 가질 수 있으며, 각 버전은 자신을 생성한 트랜잭션 ID(xmin)와 연결된다.

- 일관된 스냅샷 (Consistent Snapshot): 각 트랜잭션은 자신이 시작된 시점을 기준으로 데이터베이스의 일관된 스냅샷을 본다. 따라서 트랜잭션이 실행되는 동안 다른 동시 트랜잭션이 데이터를 수정하더라도, 해당 트랜잭션은 자신의 스냅샷에 포함된 데이터 버전만 보게 되어 안정적인 조회가 가능하다.
- 가시성 규칙 (Visibility Rules): 특정 트랜잭션에게 어떤 버전의 튜플이 '보이는지'를 결정하는 규칙이다. PostgreSQL은 튜플의 xmin, xmax 메타데이터와 현재 트랜잭션의 상태를 비교하여, 해당 트랜잭션의 스냅샷 시점에 유효했던 튜플 버전만을 반환한다.

## 데드 튜플과 VACUUM

`UPDATE` 나 `DELETE` 작업이 발생하면 기존 튜플은 더 이상 최신 버전이 아니게 된다. 이러한 구버전 튜플 중 어떤 트랜잭션에서도 더 이상 참조되지 않는 튜플을 데드 튜플(Dead Tuple)이라고 한다. 데드 튜플은 즉시 물리적으로 삭제되지 않고 디스크 공간을 차지하며 누적된다.

이러한 데드 튜플을 제거하고 디스크 공간을 회수하는 필수적인 프로세스가 바로 VACUUM 이다.`AUTOVACUUM` 데몬은 주기적으로 데드 튜플을 정리하여 데이터베이스의 성능 저하를 방지하고 효율성을 유지하는 중요한 역할을 수행한다.

# 6. WAL (Write-Ahead Logging)과 데이터 지속성

ACID의 지속성(Durability)을 보장하기 위해 PostgreSQL이 사용하는 핵심 기술은 WAL(Write-Ahead Logging)이다. 이름 그대로, 데이터 변경 사항을 실제 데이터 파일(힙 파일)에 적용하기 전에, 모든 변경 내용을 로그(log)에 먼저 기록하는 방식이다.

- **지속성 보장**: 모든 변경 사항은 먼저 디스크의 순차적인 WAL 파일에 기록된다. WAL 기록이 성공적으로 디스크에 저장된 후에야 트랜잭션이 커밋된다. 이로써 시스템 장애가 발생해도 WAL을 통해 데이터를 복구할 수 있다.
- **크래시 복구 (Crash Recovery)**: 만약 데이터베이스가 메모리의 변경된 데이터(더티 페이지)를 디스크에 미처 기록하지 못한 상태에서 충돌이 발생하면, 재시작 시 WAL 항목을 다시 재생(replay)하여 데이터베이스를 일관된 상태로 복구할 수 있다.
- **복제 (Replication)**: WAL 스트림은 데이터베이스 복제에도 활용된다. 보조 서버(Secondary Server)는 주 서버(Primary Server)의 WAL 스트림을 거의 실시간으로 받아 재생함으로써, 일관된 읽기 전용 복제본(Read Replica) 또는 장애 대비용 스탠바이 서버(Failover Standby)를 유지할 수 있다.
- **성능 향상**: 디스크에 임의의 위치에 쓰는 작업(Random Write)은 순차적으로 쓰는 작업(Sequential Write)보다 훨씬 느리다. WAL은 모든 변경 사항을 순차적인 로그 파일에 기록하므로, 데이터 페이지에 대한 비싼 임의 쓰기 작업을 최소화하여 성능과 안전성을 동시에 확보한다.

# 7. 체크포인트: 메모리와 디스크의 동기화

체크포인트(Checkpoint)는 데이터 지속성을 보장하고 효율적인 크래시 복구를 가능하게 하는 중요한 백그라운드 프로세스다. 이는 데이터베이스의 메모리 내 상태와 디스크의 영구 저장소 간의 동기화 지점 역할을 한다.

## 체크포인트의 역할과 과정

체크포인트의 주된 역할은 메모리에서 변경되었지만 아직 디스크에 기록되지 않은 페이지, 즉 더티 페이지(Dirty Pages)를 주기적으로 디스크에 플러시(flush)하는 것이다. 이 작업을 통해 WAL 로그가 무한정 길어지는 것을 방지하고, 크래시 복구 시 재생해야 할 로그의 양을 제한한다.

체크포인트가 수행되면, WAL에 특별한 체크포인트 레코드가 기록된다. 이 레코드에는 모든 데이터 변경 사항이 디스크에 안전하게 기록된 WAL 상의 특정 위치, 즉 LSN(Log Sequence Number)이 포함된다.

## 빠른 크래시 복구의 핵심

예기치 않은 시스템 충돌 후 데이터베이스가 재시작될 때, PostgreSQL은 WAL의 처음부터 모든 로그를 재생할 필요가 없다. 대신, 가장 최신의 체크포인트 레코드를 찾아 복구 시작 지점을 결정한다. 그리고 해당 체크포인트 LSN 이후에 기록된 WAL 항목들만 재생하면 되므로, 복구 시간을 크게 단축할 수 있다.

결론적으로, 체크포인트의 빈도와 WAL 파일 크기 설정은 쓰기 성능과 복구 속도 사이의 중요한 균형점을 결정하는 요소가 된다.
